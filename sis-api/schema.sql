-- Schema for REST API
CREATE SCHEMA IF NOT EXISTS api AUTHORIZATION sis;
COMMENT ON SCHEMA api IS 'REST API tables';
ALTER DEFAULT PRIVILEGES FOR ROLE sis IN SCHEMA api GRANT SELECT ON TABLES TO sis_r;
GRANT USAGE ON SCHEMA api TO sis_r;


------------------------------
-- Users and authentication --
------------------------------

-- Users - For human users who log in through the web application
CREATE TABLE IF NOT EXISTS api.user (
    user_id text PRIMARY KEY, -- e-mail/user_id
    password_hash text NOT NULL,
    is_active BOOLEAN DEFAULT TRUE,
    is_admin BOOLEAN DEFAULT FALSE,
    created_at timestamp DEFAULT CURRENT_DATE,
    updated_at timestamp DEFAULT CURRENT_TIMESTAMP,
    last_login timestamp
);
COMMENT ON TABLE api.user IS 'For human users who log in through the web application';
ALTER TABLE IF EXISTS api.user OWNER to sis;
GRANT SELECT ON TABLE api.user TO sis_r;

COMMENT ON COLUMN api."user".user_id IS 'Unique identifier for the user (typically email or username)';
COMMENT ON COLUMN api."user".password_hash IS 'Bcrypt hash of the user password';
COMMENT ON COLUMN api."user".is_active IS 'Flag indicating whether the user account is active';
COMMENT ON COLUMN api."user".is_admin IS 'Flag indicating whether the user has administrator privileges';
COMMENT ON COLUMN api."user".created_at IS 'Timestamp when the user was created';
COMMENT ON COLUMN api."user".updated_at IS 'Timestamp of the last update to the user record';
COMMENT ON COLUMN api."user".last_login IS 'Timestamp of the last successful login';


-- API_client - For server-to-server authentication
CREATE TABLE IF NOT EXISTS api.api_client (
    api_client_id text,
    api_key text NOT NULL,
    is_active BOOLEAN DEFAULT TRUE,
    created_at date DEFAULT CURRENT_DATE,
    expires_at date,
    last_login timestamp,
    description text NOT NULL DEFAULT '',
    CONSTRAINT api_client_id_pkey PRIMARY KEY (api_client_id),
    CONSTRAINT api_client_api_key_key UNIQUE (api_key)
);
COMMENT ON TABLE api.api_client IS 'For server-to-server authentication';
ALTER TABLE IF EXISTS api.api_client OWNER to sis;
GRANT SELECT ON TABLE api.api_client TO sis_r;

COMMENT ON COLUMN api.api_client.api_client_id IS 'Unique identifier for the API client';
COMMENT ON COLUMN api.api_client.api_key IS 'Secret API key for authentication';
COMMENT ON COLUMN api.api_client.is_active IS 'Flag indicating whether the client is active';
COMMENT ON COLUMN api.api_client.created_at IS 'Date when the client was created';
COMMENT ON COLUMN api.api_client.expires_at IS 'Date when the API key expires';
COMMENT ON COLUMN api.api_client.last_login IS 'Timestamp of the last successful authentication';
COMMENT ON COLUMN api.api_client.description IS 'Description of the API client purpose';


-- Audit - Track authentication attempts and API usage
CREATE TABLE IF NOT EXISTS api.audit (
    audit_id integer NOT NULL GENERATED BY DEFAULT AS IDENTITY ( INCREMENT 1 START 1 MINVALUE 1 MAXVALUE 2147483647 CACHE 1 ),
    user_id text,
    api_client_id text,
    action text,
    details jsonb,
    ip_address inet,
    created_at timestamp DEFAULT CURRENT_TIMESTAMP,
    CONSTRAINT audit_pkey PRIMARY KEY (audit_id),
    CONSTRAINT audit_user_id_fkey FOREIGN KEY (user_id)
        REFERENCES api.user (user_id) MATCH SIMPLE
        ON UPDATE CASCADE
        ON DELETE NO ACTION,
    CONSTRAINT audit_api_client_id_fkey FOREIGN KEY (api_client_id)
        REFERENCES api.api_client (api_client_id) MATCH SIMPLE
        ON UPDATE CASCADE
        ON DELETE NO ACTION
);
COMMENT ON TABLE api.audit IS 'Track authentication attempts and API usage';
ALTER TABLE IF EXISTS api.audit OWNER to sis;
GRANT SELECT ON TABLE api.audit TO sis_r;

COMMENT ON COLUMN api.audit.audit_id IS 'Synthetic primary key for the audit record';
COMMENT ON COLUMN api.audit.user_id IS 'Reference to the user who performed the action';
COMMENT ON COLUMN api.audit.api_client_id IS 'Reference to the API client that performed the action';
COMMENT ON COLUMN api.audit.action IS 'Type of action performed';
COMMENT ON COLUMN api.audit.details IS 'JSON object with action details';
COMMENT ON COLUMN api.audit.ip_address IS 'IP address from which the action was performed';
COMMENT ON COLUMN api.audit.created_at IS 'Timestamp when the action occurred';


-------------------------------
-- Application costumization --
-------------------------------

-- Application settings
CREATE TABLE IF NOT EXISTS api.setting (
    key text PRIMARY KEY,
    value text
);
ALTER TABLE IF EXISTS api.setting OWNER to sis;
GRANT SELECT ON TABLE api.setting TO sis_r;

COMMENT ON TABLE api.setting IS 'Key-value store for API configuration settings';
COMMENT ON COLUMN api.setting.key IS 'Setting identifier key';
COMMENT ON COLUMN api.setting.value IS 'Setting value';


-- Layer management
CREATE TABLE IF NOT EXISTS api.layer (
    project_id text,
    project_name text,
    layer_id text PRIMARY KEY,
    publish BOOLEAN DEFAULT TRUE,
    property_name text,
    dimension text,
    version text,
    unit_of_measure_id text REFERENCES soil_data.unit_of_measure(unit_of_measure_id),
    metadata_url text,
    download_url text,
    get_map_url text,
    get_legend_url text,
    get_feature_info_url text
);
ALTER TABLE IF EXISTS api.layer OWNER to sis;
GRANT SELECT ON TABLE api.layer TO sis_r;

COMMENT ON TABLE api.layer IS 'API layer for exposing spatial data layers through the REST API';
COMMENT ON COLUMN api.layer.project_id IS 'Reference to the project this layer belongs to';
COMMENT ON COLUMN api.layer.project_name IS 'Human-readable name of the project';
COMMENT ON COLUMN api.layer.layer_id IS 'Unique identifier for the layer';
COMMENT ON COLUMN api.layer.publish IS 'Flag indicating whether the layer is published and accessible via API';
COMMENT ON COLUMN api.layer.property_name IS 'Name of the soil property this layer represents';
COMMENT ON COLUMN api.layer.dimension IS 'Dimension type (e.g., depth, time)';
COMMENT ON COLUMN api.layer.version IS 'Version identifier of the layer';
COMMENT ON COLUMN api.layer.unit_of_measure_id IS 'Reference to the unit of measure for layer values';
COMMENT ON COLUMN api.layer.metadata_url IS 'URL to the layer metadata document';
COMMENT ON COLUMN api.layer.download_url IS 'URL for downloading the layer data';
COMMENT ON COLUMN api.layer.get_map_url IS 'WMS GetMap URL for the layer';
COMMENT ON COLUMN api.layer.get_legend_url IS 'WMS GetLegendGraphic URL for the layer';
COMMENT ON COLUMN api.layer.get_feature_info_url IS 'WMS GetFeatureInfo URL for the layer';


------------------------------------
-- Client REST API endpoint views --
------------------------------------

-- view to expose the list of soil properties and geographical extent
CREATE OR REPLACE VIEW api.vw_api_manifest AS
SELECT 
    opc.property_num_id AS property,
    COUNT(DISTINCT p.profile_id) AS profiles,
    COUNT(rpc.result_num_id) AS observations,
    ST_Envelope(ST_Collect(p.geom)) AS geom
FROM soil_data.observation_num opc
    INNER JOIN soil_data.result_num rpc ON opc.observation_num_id = rpc.observation_num_id
    INNER JOIN soil_data.specimen s ON rpc.specimen_id = s.specimen_id
    INNER JOIN soil_data.element e ON s.element_id = e.element_id
    INNER JOIN soil_data.profile p ON e.profile_id = p.profile_id
    INNER JOIN soil_data.plot plt ON p.plot_id = plt.plot_id
GROUP BY opc.property_num_id
ORDER BY opc.property_num_id;
COMMENT ON VIEW api.vw_api_manifest IS 'View to expose the list of soil properties and geographical extent';
ALTER TABLE IF EXISTS api.vw_api_manifest OWNER to sis;
GRANT SELECT ON TABLE api.vw_api_manifest TO sis_r;


-- view to expose the list of profiles
CREATE OR REPLACE VIEW api.vw_api_profile AS
SELECT 
    p.profile_id AS gid,
    p.profile_code,
    proj.name AS project_name,
    p.altitude,
    p.time_stamp AS date,
    p.geom AS geom,
    ST_AsGeoJSON(plt.geom)::json AS geometry
FROM soil_data.profile p
    INNER JOIN soil_data.plot plt ON p.plot_id = plt.plot_id
    INNER JOIN soil_data.site s ON plt.site_id = s.site_id
    LEFT JOIN soil_data.project_site ps ON s.site_id = ps.site_id
    LEFT JOIN soil_data.project proj ON ps.project_id = proj.project_id
WHERE p.geom IS NOT NULL
ORDER BY p.profile_id;
COMMENT ON VIEW api.vw_api_profile IS 'View to expose the list of profiles';
ALTER TABLE IF EXISTS api.vw_api_profile OWNER to sis;
GRANT SELECT ON TABLE api.vw_api_profile TO sis_r;


-- view to expose the observational data
CREATE OR REPLACE VIEW api.vw_api_observation AS
SELECT p3.profile_code,
    e.upper_depth,
    e.lower_depth,
    o.property_num_id,
    o.procedure_num_id,
    r.value,
    o.unit_of_measure_id
   FROM soil_data.project p
     LEFT JOIN soil_data.project_site sp ON sp.project_id = p.project_id
     LEFT JOIN soil_data.site s ON s.site_id = sp.site_id
     LEFT JOIN soil_data.plot p2 ON p2.site_id = s.site_id
     LEFT JOIN soil_data.profile p3 ON p3.plot_id = p2.plot_id
     LEFT JOIN soil_data.element e ON e.profile_id = p3.profile_id
     LEFT JOIN soil_data.specimen s2 ON s2.element_id = e.element_id
     LEFT JOIN soil_data.result_num r ON r.specimen_id = s2.specimen_id
     LEFT JOIN soil_data.observation_num o ON o.observation_num_id = r.observation_num_id
  ORDER BY p3.profile_code, e.upper_depth, o.property_num_id;
COMMENT ON VIEW api.vw_api_observation IS 'View to expose the observational data';
ALTER TABLE IF EXISTS api.vw_api_observation OWNER to sis;
GRANT SELECT ON TABLE api.vw_api_observation TO sis_r;


------------------
-- Data upload  --
------------------

CREATE SCHEMA IF NOT EXISTS soil_data_upload AUTHORIZATION sis;
COMMENT ON SCHEMA soil_data_upload IS 'Schema to upload soil data';
ALTER DEFAULT PRIVILEGES FOR ROLE sis IN SCHEMA soil_data_upload GRANT SELECT ON TABLES TO sis_r;
GRANT USAGE ON SCHEMA soil_data_upload TO sis_r;


CREATE TABLE IF NOT EXISTS api.uploaded_dataset (
    user_id text,
    project_id text,
    table_name text PRIMARY KEY,
    file_name TEXT NOT NULL UNIQUE,
    upload_date DATE DEFAULT CURRENT_DATE,
    ingestion_date date,
    status text,
    depth_if_topsoil smallint,
    n_rows integer,
    n_col smallint,
    has_cords boolean,
    cords_epsg integer,
    cords_check boolean DEFAULT false,
    note text,
    CONSTRAINT uploaded_dataset_status_check CHECK (status = ANY (ARRAY['Uploaded', 'Ingested', 'Removed'])),
    CONSTRAINT uploaded_dataset_project_id_fkey FOREIGN KEY (project_id)
        REFERENCES soil_data.project (project_id) MATCH SIMPLE
        ON UPDATE CASCADE
        ON DELETE NO ACTION,
    CONSTRAINT uploaded_dataset_user_id_fkey FOREIGN KEY (user_id)
        REFERENCES api.user (user_id) MATCH SIMPLE
        ON UPDATE CASCADE
        ON DELETE NO ACTION
);
ALTER TABLE IF EXISTS api.uploaded_dataset OWNER to sis;
GRANT SELECT ON TABLE api.uploaded_dataset TO sis_r;

COMMENT ON TABLE api.uploaded_dataset IS 'Tracks datasets uploaded by users for ingestion into the soil data schema';
COMMENT ON COLUMN api.uploaded_dataset.user_id IS 'Reference to the user who uploaded the dataset';
COMMENT ON COLUMN api.uploaded_dataset.project_id IS 'Reference to the project this dataset belongs to';
COMMENT ON COLUMN api.uploaded_dataset.table_name IS 'Name of the staging table containing the uploaded data';
COMMENT ON COLUMN api.uploaded_dataset.file_name IS 'Original filename of the uploaded file';
COMMENT ON COLUMN api.uploaded_dataset.upload_date IS 'Date when the file was uploaded';
COMMENT ON COLUMN api.uploaded_dataset.ingestion_date IS 'Date when the data was ingested into the main schema';
COMMENT ON COLUMN api.uploaded_dataset.status IS 'Current status: Uploaded, Ingested, or Removed';
COMMENT ON COLUMN api.uploaded_dataset.depth_if_topsoil IS 'Depth in cm if this is topsoil data';
COMMENT ON COLUMN api.uploaded_dataset.n_rows IS 'Number of rows in the uploaded dataset';
COMMENT ON COLUMN api.uploaded_dataset.n_col IS 'Number of columns in the uploaded dataset';
COMMENT ON COLUMN api.uploaded_dataset.has_cords IS 'Flag indicating whether the dataset contains coordinates';
COMMENT ON COLUMN api.uploaded_dataset.cords_epsg IS 'EPSG code of the coordinate reference system';
COMMENT ON COLUMN api.uploaded_dataset.cords_check IS 'Flag indicating whether coordinates have been validated';
COMMENT ON COLUMN api.uploaded_dataset.note IS 'Additional notes about the dataset';


CREATE TABLE IF NOT EXISTS api.uploaded_dataset_column
(
    table_name text NOT NULL,
    column_name text NOT NULL,
    property_num_id text,
    procedure_num_id text,
    unit_of_measure_id text,
    ignore_column boolean DEFAULT false,
    note text,
    CONSTRAINT uploaded_dataset_column_pkey PRIMARY KEY (table_name, column_name),
    CONSTRAINT uploaded_dataset_column_table_name_fkey FOREIGN KEY (table_name)
        REFERENCES api.uploaded_dataset (table_name) MATCH SIMPLE
        ON UPDATE CASCADE
        ON DELETE CASCADE,
    CONSTRAINT uploaded_dataset_column_property_num_id_fkey FOREIGN KEY (property_num_id)
        REFERENCES soil_data.property_num (property_num_id) MATCH SIMPLE
        ON UPDATE CASCADE
        ON DELETE NO ACTION,
    CONSTRAINT uploaded_dataset_column_procedure_num_id_fkey FOREIGN KEY (procedure_num_id)
        REFERENCES soil_data.procedure_num (procedure_num_id) MATCH SIMPLE
        ON UPDATE CASCADE
        ON DELETE SET NULL,
    CONSTRAINT uploaded_dataset_column_unit_of_measure_id_fkey FOREIGN KEY (unit_of_measure_id)
        REFERENCES soil_data.unit_of_measure (unit_of_measure_id) MATCH SIMPLE
        ON UPDATE CASCADE
        ON DELETE NO ACTION
);
ALTER TABLE IF EXISTS api.uploaded_dataset_column OWNER to sis;
GRANT SELECT ON TABLE api.uploaded_dataset_column TO sis_r;

COMMENT ON TABLE api.uploaded_dataset_column IS 'Column mapping configuration for uploaded datasets';
COMMENT ON COLUMN api.uploaded_dataset_column.table_name IS 'Reference to the uploaded dataset table';
COMMENT ON COLUMN api.uploaded_dataset_column.column_name IS 'Name of the column in the uploaded dataset';
COMMENT ON COLUMN api.uploaded_dataset_column.property_num_id IS 'Mapped soil property identifier';
COMMENT ON COLUMN api.uploaded_dataset_column.procedure_num_id IS 'Mapped analytical procedure identifier';
COMMENT ON COLUMN api.uploaded_dataset_column.unit_of_measure_id IS 'Mapped unit of measure identifier';
COMMENT ON COLUMN api.uploaded_dataset_column.ignore_column IS 'Flag to ignore this column during ingestion';
COMMENT ON COLUMN api.uploaded_dataset_column.note IS 'Additional notes about the column mapping';
